from invoke import task, UnexpectedExit

from os import path, makedirs, listdir, remove, chdir, environ
from pathlib import Path
import shutil
import json

DESCRIPTION = "SEDAS Manager project toolkit, run --list to get info about args"
PATH = str(Path(__file__).parent)

PURPLE = '\033[0;35m'
BLUE = '\033[0;34m'
NC = '\033[0m'

# TODO: add for windows also
NVM_PREPEND_LINUX = "source $HOME/.nvm/nvm.sh && nvm use &&"
ELECTRON_PATH = path.join(PATH, "node_modules/.bin/electron")
FORGE_PATH = path.join(PATH, "node_modules/.bin/electron-forge")
SET_PROJ_ROOT = f"cd {PATH} &&"


# functions
def makefile(path):
    with open(path, "w"):
        pass


def openfile(path):
    with open(path, "r") as file:
        return file.read()


def print_color(color, text):
    print(color + text + NC)


@task
def clean(ctx):
    """
        Clean working directories of autogenerated files
    """

    path_src = path.join(PATH, "src")
    path_workers = path.join(PATH, "src/workers")
    path_build = path.join(PATH, "out")
    path_cpp_build = path.join(PATH, "src/build")
    path_module_build = path.join(PATH, "src/addons/modules/build")

    path_sedas_ai_src = path.join(PATH, "src/addons/modules/bin/SEDAS-AI-backend/src")

    def check_files(folder_path):
        for filename in listdir(folder_path):
            file_path = path.join(folder_path, filename)

            if not path.isfile(file_path):
                continue

            if "map" in filename or "js" in filename:
                remove(file_path)

    def clean_folder(folder_path, file):
        shutil.rmtree(folder_path)
        makedirs(folder_path)
        makefile(path.join(folder_path, file))

    print_color(PURPLE, "Starting autogenerated files clean...")

    check_files(path_src)
    check_files(path_workers)

    print_color(PURPLE, "Cleaned directories from autogenerated files")

    clean_folder(path_build, ".gitkeep")
    clean_folder(path_cpp_build, ".gitkeep")
    clean_folder(path_module_build, ".gitkeep")

    print_color(PURPLE, "Cleared build dirs")

    # clean module build dirs
    chdir(path_sedas_ai_src)
    ctx.run("invoke clean", pty=True)

    print_color(PURPLE, "Cleaned module dirs")


@task
def compile(ctx, only="none", refetch=False):
    """
        Compile target files
            1) TS -> JS
            2) C++ -> bind to TS part
            3) Python updater to executable
            4) Compile all modules and move them to the module build directory
    """
    def compile_cpp():
        path_src = path.join(PATH, "src")
        ctx.run(f"cd {path_src} && {NVM_PREPEND_LINUX} node-gyp configure build", pty=True)
        chdir(PATH)
        print_color(PURPLE, "Built all C++ files")

    def compile_ts():
        ctx.run(f"{SET_PROJ_ROOT} {NVM_PREPEND_LINUX} npx tsc --project ./tsconfig.json", pty=True)
        print_color(PURPLE, "Compiled Typescript")

    def compile_updater():
        path_updater = path.join(PATH, "src/updater")
        path_build_install = path.join(path_updater, "build/install")
        path_build_uninstall = path.join(path_updater, "build/uninstall")

        chdir(path_updater)

        # removing build dirs
        shutil.rmtree(path_build_install)
        shutil.rmtree(path_build_uninstall)

        ctx.run("pyinstaller install.spec")
        print_color(PURPLE, "Compiled Installer")
        ctx.run("pyinstaller uninstall.spec")
        print_color(PURPLE, "Compiled Uninstaller")

    def compile_modules():

        path_modules = path.join(PATH, "src/addons/modules/bin")

        # Compile SEDAS-AI-backend
        sedas_ai_backend = path.join(path_modules, "SEDAS-AI-backend/src")
        sedas_tts_resources = path.join(sedas_ai_backend, "PlaneResponse/models/tts/voices")
        sedas_asr_resource = path.join(sedas_ai_backend, "PlaneResponse/models/asr/atc-whisper-ggml.bin")

        chdir(sedas_ai_backend)

        # check TTS resource fetching
        if len(listdir(sedas_tts_resources)) == 1:
            print_color(PURPLE, "Fetching TTS resources for SEDAS-AI-backend (this my take some while)")
            ctx.run("invoke fetch-resources -t=tts") # fetch tts resources

        # check ASR resource fetching
        if not path.exists(sedas_asr_resource) or refetch: # or if the user enforced the refetch
            ctx.run("invoke fetch-resources -t=asr") # fetch asr resources

        ctx.run("invoke build-deps") # build the whisper.cpp runner
        ctx.run("invoke build --DTESTING=OFF")
        print_color(PURPLE, "Compiled SEDAS-AI-backend")

        print_color(PURPLE, "Moving built files to /build directory...")
        sedas_ai_project_build = path.join(path_modules, "SEDAS-AI-backend/project_build")
        sedas_ai_global_build = path.join(PATH, "src/addons/modules/build/sedas_ai_backend")
        shutil.copytree(sedas_ai_project_build, sedas_ai_global_build, dirs_exist_ok=True)

        # TODO: maybe add more modules?

        print_color(PURPLE, "Done!")

    if only == "none":
        print_color(PURPLE, "Compiling target files...")
        compile_cpp()
        compile_ts()
        compile_updater()
        compile_modules()
        print_color(PURPLE, "Compiled target files")
    elif only == "cpp": compile_cpp()
    elif only == "ts": compile_ts()
    elif only == "modules": compile_modules()
    elif only == "updater": compile_updater()


@task
def devel(ctx, obj):
    """
        Run app in development mode
    """

    if obj == "app":
        path_main = path.join(PATH, "src/main.js")
        print_color(PURPLE, "Running app in dev mode...")
        print(f"{ELECTRON_PATH} {path_main}")
        ctx.run(f"{SET_PROJ_ROOT} {NVM_PREPEND_LINUX} {ELECTRON_PATH} {path_main}", pty=True)

    elif obj == "install":
        print_color(PURPLE, "Running installer in dev mode...")

        try:
            result = ctx.run("python ./src/updater/install.py")
            print(f"App exited with code: {result.exited}")
        except UnexpectedExit as e: print(f"App failed with code: {e.result.exited}")

    elif obj == "uninstall":
        print_color(PURPLE, "Running uninstaller in dev mode...")
        ctx.run("python ./src/updater/uninstall.py")


@task
def debug(ctx):
    """
        Run app in debug mode
    """

    path_main = path.join(PATH, "src/main.js")
    print_color(PURPLE, "Running app in debug mode...")
    ctx.run(f"{SET_PROJ_ROOT} {NVM_PREPEND_LINUX} {ELECTRON_PATH} --inspect=9229 {path_main}", pty=True)


@task
def build(ctx, verbose=False):
    """
        Create SEDAS executable
    """

    print_color(PURPLE, "Building app...")
    if verbose: command = f"{SET_PROJ_ROOT} {NVM_PREPEND_LINUX} DEBUG=electron-forge:* {FORGE_PATH} make --verbose"
    else: command = f"{SET_PROJ_ROOT} {NVM_PREPEND_LINUX} {FORGE_PATH} make"
    ctx.run(command, pty=True)


@task
def update(ctx):
    """
        Update submodules to newest commit
    """
    print_color(PURPLE, "Updating submodules...")
    ctx.run("git submodule update --remote --recursive", pty=True)

    # reinstall SEDAS-AI-backend module requirements.txt if something was added
    print_color(PURPLE, "Checking main tasks.py dependencies...")
    sedas_ai_backend_requirements = path.join(PATH, "src/addons/modules/bin/SEDAS-AI-backend/requirements.txt")
    ctx.run(f"pip install -r {sedas_ai_backend_requirements}")

    print_color(PURPLE, "Done!")


@task
def publish(ctx, verbose=False):
    """
        Publish SEDAS executable
    """

    git_var = None
    try:
        git_var = environ["GITHUB_TOKEN"] # try to access token if available
    except KeyError: # not defined yet
        print_color(PURPLE, "Setting Token")
        with open("./token.json", "r") as file:
            data = json.load(file)
            environ["GITHUB_TOKEN"] = data.get("token")
    git_var = environ["GITHUB_TOKEN"]

    print_color(PURPLE, f"Environment variable is: {git_var}")
    print_color(PURPLE, "Publishing app...")

    if verbose: command = f"{SET_PROJ_ROOT} {NVM_PREPEND_LINUX} DEBUG=electron-forge:* {FORGE_PATH} publish --verbose"
    else: command = f"{SET_PROJ_ROOT} {NVM_PREPEND_LINUX} {FORGE_PATH} publish"

    ctx.run(command, pty=True, env=environ)


# runtime
print_color(PURPLE, DESCRIPTION)
