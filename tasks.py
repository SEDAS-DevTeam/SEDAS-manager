from invoke.tasks import task # type: ignore
from invoke.context import Context
from invoke.exceptions import UnexpectedExit
from invoke.runners import Result

from os import path, makedirs, listdir, remove, chdir, environ
from pathlib import Path
from tabulate import tabulate

import shutil
import json
import sys

DESCRIPTION = "SEDAS Manager project toolkit, run --list to get info about args"
PATH = str(Path(__file__).parent)

PURPLE = '\033[0;35m'
BLUE = '\033[0;34m'
BOLD = "\033[1m"
ITALIC = "\033[3m"
NC = '\033[0m'

# TODO: add for windows also
NVM_PREPEND_LINUX = "source $HOME/.nvm/nvm.sh && nvm use &&"
ELECTRON_PATH = path.join(PATH, "node_modules/.bin/electron")
FORGE_PATH = path.join(PATH, "node_modules/.bin/electron-forge")
SET_PROJ_ROOT = f"cd {PATH} &&"


# functions
def makefile(path: str) -> None:
    with open(path, "w"):
        pass


def openfile(path: str) -> str:
    with open(path, "r") as file:
        return file.read()


def print_color(color: str, text: str) -> None:
    print(color + text + NC)


def fetch(ctx: Context, only: str = "none") -> None:

    # TODO: add a way to do this in multiple modules
    path_modules = path.join(PATH, "src/addons/modules/bin")

    # SEDAS-AI-backend
    sedas_ai_backend = path.join(path_modules, "SEDAS-AI-backend/src")

    def fetch_tts():
        sedas_tts_resources = path.join(sedas_ai_backend, "PlaneResponse/models/tts/voices")

        # delete existing models in the means of overwriting them
        shutil.rmtree(sedas_tts_resources)
        makedirs(sedas_tts_resources)
        makefile(path.join(sedas_tts_resources, ".gitkeep"))

        print_color(PURPLE, "Fetching TTS resources for SEDAS-AI-backend... (this my take a while)")

        chdir(sedas_ai_backend)
        ctx.run("invoke fetch-resources -t=tts", pty=True) # fetch tts resources

    def fetch_asr():
        print_color(PURPLE, "Fetching ASR resources for SEDAS-AI-backend...")

        chdir(sedas_ai_backend)
        ctx.run("invoke fetch-resources -t=asr", pty=True) # fetch asr resources

    if only == "none":
        fetch_tts()
        fetch_asr()
    elif only == "tts":
        fetch_tts()
    elif only == "asr":
        fetch_asr()


@task
def clean(ctx: Context):
    """
        Clean working directories of autogenerated files
    """

    path_src = path.join(PATH, "src")
    path_workers = path.join(PATH, "src/workers")
    path_build = path.join(PATH, "out")
    path_cpp_build = path.join(PATH, "src/build")
    path_module_build = path.join(PATH, "src/addons/modules/build")

    path_sedas_ai_src = path.join(PATH, "src/addons/modules/bin/SEDAS-AI-backend/src")

    def check_files(folder_path: str):
        for filename in listdir(folder_path):
            file_path = path.join(folder_path, filename)

            if not path.isfile(file_path):
                continue

            if "map" in filename or "js" in filename:
                remove(file_path)

    def clean_folder(folder_path: str, file: str):
        shutil.rmtree(folder_path)
        makedirs(folder_path)
        makefile(path.join(folder_path, file))

    print_color(PURPLE, "Starting autogenerated files clean...")

    check_files(path_src)
    check_files(path_workers)

    print_color(PURPLE, "Cleaned directories from autogenerated files")

    clean_folder(path_build, ".gitkeep")
    clean_folder(path_cpp_build, ".gitkeep")
    clean_folder(path_module_build, ".gitkeep")

    print_color(PURPLE, "Cleared build dirs")

    # clean module build dirs
    chdir(path_sedas_ai_src)
    ctx.run("invoke clean", pty=True)

    print_color(PURPLE, "Cleaned module dirs")


@task
def compile(ctx: Context, only: str = "none", refetch: bool = False):
    """
        Compile target files
            1) TS -> JS
            2) C++ -> bind to TS part
            3) Python updater to executable
            4) Compile all modules and move them to the module build directory
    """
    def compile_cpp():
        path_src = path.join(PATH, "src")
        ctx.run(f"cd {path_src} && {NVM_PREPEND_LINUX} node-gyp configure build", pty=True)
        chdir(PATH)
        print_color(PURPLE, "Built all C++ files")

    def compile_ts():
        ctx.run(f"{SET_PROJ_ROOT} {NVM_PREPEND_LINUX} npx tsc --project ./tsconfig.electron.json", pty=True)
        print_color(PURPLE, "Compiled Typescript")

    def compile_updater():
        path_updater = path.join(PATH, "src/updater")
        path_build_install = path.join(path_updater, "build/install")
        path_build_uninstall = path.join(path_updater, "build/uninstall")

        chdir(path_updater)

        # removing build dirs
        shutil.rmtree(path_build_install)
        shutil.rmtree(path_build_uninstall)

        ctx.run("pyinstaller install.spec")
        print_color(PURPLE, "Compiled Installer")
        ctx.run("pyinstaller uninstall.spec")
        print_color(PURPLE, "Compiled Uninstaller")

    def compile_modules():

        path_modules = path.join(PATH, "src/addons/modules/bin")

        # Compile SEDAS-AI-backend
        sedas_ai_backend = path.join(path_modules, "SEDAS-AI-backend/src")
        sedas_tts_resources = path.join(sedas_ai_backend, "PlaneResponse/models/tts/voices")
        sedas_asr_resource = path.join(sedas_ai_backend, "PlaneResponse/models/asr/atc-whisper-ggml.bin")

        # check TTS resource fetching
        if len(listdir(sedas_tts_resources)) == 1 or refetch: fetch(ctx, "tts")

        # check ASR resource fetching
        if not path.exists(sedas_asr_resource) or refetch: fetch(ctx, "asr")

        chdir(sedas_ai_backend)

        ctx.run("invoke build-deps") # build the whisper.cpp runner

        # build the SEDAS-AI-backend runner
        if refetch: ctx.run("invoke build --DTESTING=OFF --rewrite")
        else: ctx.run("invoke build --DTESTING=OFF")
        print_color(PURPLE, "Compiled SEDAS-AI-backend")

        print_color(PURPLE, "Moving built files from /project_build to /build directory...")
        sedas_ai_project_build = path.join(path_modules, "SEDAS-AI-backend/project_build")
        sedas_ai_global_build = path.join(PATH, "src/addons/modules/build/sedas_ai_backend")
        shutil.copytree(sedas_ai_project_build, sedas_ai_global_build, dirs_exist_ok=True)

        # TODO: maybe add more modules?

        print_color(PURPLE, "Done!")

    if only == "none":
        print_color(PURPLE, "Compiling target files...")
        compile_cpp()
        compile_ts()
        compile_updater()
        compile_modules()
        print_color(PURPLE, "Compiled target files")
    elif only == "cpp": compile_cpp()
    elif only == "ts": compile_ts()
    elif only == "modules": compile_modules()
    elif only == "updater": compile_updater()


@task
def devel(ctx: Context, obj: str):
    """
        Run app in development mode
    """

    class StreamCapturer:
        def __init__(self):
            self.output: str = ""
            self.exited = False
        def write(self, data: str):
            if not self.exited:
                sys.stdout.write(data)
                sys.stdout.flush()
            self.output += data
            if "exited with code 0" in data and "wait-on" in data:
                self.exited = True
                sys.exit(0)
        def flush(self):
            pass

    if obj == "app":
        path_main = path.join(PATH, "src/main/main_dev.js")
        print_color(PURPLE, "Running app in dev mode...")
        print(f"{ELECTRON_PATH} {path_main}")
        stream_capturer = StreamCapturer()
        try:
            ctx.run(
                f"{SET_PROJ_ROOT} {NVM_PREPEND_LINUX} npx concurrently 'vite' 'wait-on http://localhost:5173 && {ELECTRON_PATH} {path_main} --devel_path={PATH}'",
                pty=True,
                out_stream=stream_capturer,
            )
        except Exception as e:
            if not stream_capturer.exited:
                raise e  # Re-raise if the exception was not due to our intended exit

            print_color(PURPLE, "Exited dev server")

    elif obj == "install":
        print_color(PURPLE, "Running installer in dev mode...")

        try:
            result: Result | None = ctx.run(f"python ./src/updater/install.py {PATH}")
            if result is None: print("Exit code is Null")
            else: print(f"App exited with code: {result.exited}")
        except UnexpectedExit as e: print(f"App failed with code: {e.result.exited}")

    elif obj == "uninstall":
        print_color(PURPLE, "Running uninstaller in dev mode...")
        ctx.run(f"python ./src/updater/uninstall.py {PATH}")


@task
def debug(ctx: Context):
    """
        Show how to run app in debug mode in different IDEs
    """
    print("This table will show you how to debug SEDAS in different IDEs/Editors.")
    print(tabulate([
        ["VSCode", f"{BOLD}.vscode{NC} files are defined in the project root. So the only thing needed is just to run {BOLD}Debug SEDAS{NC} task in the {BOLD}Run and Debug{NC} panel"],
        ["Zed editor", f"{BOLD}TODO{NC}"]],
        [f"{ITALIC}IDE/Editor{NC}", f"{ITALIC}Howto{NC}"],
        tablefmt="grid"))


@task
def build(ctx: Context, verbose: bool = False):
    """
        Create SEDAS executable
    """

    print_color(PURPLE, "Building app...")
    if verbose: command = f"{SET_PROJ_ROOT} {NVM_PREPEND_LINUX} DEBUG=electron-forge:* {FORGE_PATH} make --verbose"
    else: command = f"{SET_PROJ_ROOT} {NVM_PREPEND_LINUX} {FORGE_PATH} make"
    ctx.run(command, pty=True)


@task
def update(ctx: Context):
    """
        Update submodules to newest commit
    """
    print_color(PURPLE, "Updating submodules...")
    ctx.run("git submodule update --remote --recursive", pty=True)

    # reinstall SEDAS-AI-backend module requirements.txt if something was added
    print_color(PURPLE, "Checking main tasks.py dependencies...")
    sedas_ai_backend_requirements = path.join(PATH, "src/addons/modules/bin/SEDAS-AI-backend/requirements.txt")
    ctx.run(f"pip install -r {sedas_ai_backend_requirements}")

    print_color(PURPLE, "Done!")


@task
def publish(ctx: Context, verbose: bool = False):
    """
        Publish SEDAS executable
    """

    git_var = None
    try:
        git_var = environ["GITHUB_TOKEN"] # try to access token if available
    except KeyError: # not defined yet
        print_color(PURPLE, "Setting Token")
        with open("./token.json", "r") as file:
            data = json.load(file)
            environ["GITHUB_TOKEN"] = data.get("token")
    git_var = environ["GITHUB_TOKEN"]

    print_color(PURPLE, f"Environment variable is: {git_var}")
    print_color(PURPLE, "Publishing app...")

    if verbose: command = f"{SET_PROJ_ROOT} {NVM_PREPEND_LINUX} DEBUG=electron-forge:* {FORGE_PATH} publish --verbose"
    else: command = f"{SET_PROJ_ROOT} {NVM_PREPEND_LINUX} {FORGE_PATH} publish"

    ctx.run(command, pty=True, env=environ)


@task
def check_structure(ctx: Context):
    """
    Check for project internal structure and linkages in .JS files
    """
    command = "npx madge --exclude '^src\/addons\/' --image ./extra/js_structure.svg --extensions ts ."
    ctx.run(command, pty=True, env=environ)
    print_color(PURPLE, "Generated project_structure SVG is in ./extra directory (if you see any warnings generated, it possibly means that there are some circular dependencies)")

# runtime
print_color(PURPLE, DESCRIPTION)
